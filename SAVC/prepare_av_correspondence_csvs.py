#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Code to prepare the audio, visual couplings for the Supervised Audiovisual 
Correspondence (SAVC) task.
"""

import pandas as pd
import numpy as np
from pathlib import Path
from functools import partial
import itertools
from random import shuffle

# %% Read in AVMIT csv data
AVMIT_train_df = pd.read_csv(
    'audiovisual_action_recognition/AVMIT_train.csv'
)
AVMIT_val_df = pd.read_csv(
    'audiovisual_action_recognition/AVMIT_validation.csv'
)

# %% Read in MIT-16 csv data
MIT16_train_df = pd.read_csv(
    'audiovisual_action_recognition/MIT16_train.csv'
)
MIT16_val_df = pd.read_csv(
    'audiovisual_action_recognition/MIT16_validation.csv'
)

# %% Get data showing whether MIT-16 videos have audio or not
audio_or_not = pd.read_csv(
    'audiovisual_similarity/MIT16_audio_or_not.csv'
) # data generated by audiovisual_similarity/audio_present.py

# %%

def all_possible_filename_combinations(filename_ls):
    """ Returns a list of tuples, where each tuple is a unique combination of 
        elements from the list. The list contains all possible combinations of
        size 2.
    """
    # get all combination pairs of tfrecords within this label
    congruent_tfrecords_1 = list(itertools.combinations(filename_ls, 2))
    congruent_tfrecords_2 = [
        (tup[1], tup[0]) for tup in congruent_tfrecords_1
    ]
    
    congruent_tfrecords = congruent_tfrecords_1 + congruent_tfrecords_2
    
    # add original video list (405 videos)
    congruent_tfrecords.extend(
        [(f,f) for f in filename_ls]
    )
    
    return congruent_tfrecords


def sample_filename_combinations(filename_ls, sample_size):
    """ Returns a list of tuples, where each tuple is a unique combination of 
        elements from the list. The list contains some possible combinations of
        2 filenames. Sample size is the number of samples to take for each 
        video (the number of audio streams paired with a visual stream).
    """
    filename_ls_copy = filename_ls.copy()
        
    congruent_tfrecords = []
    for i in range(sample_size):
        shuffle(filename_ls_copy) # shuffle
        cong_tup_ls = list(zip(filename_ls, filename_ls_copy)) # combine
        congruent_tfrecords.extend(cong_tup_ls) # record
    
    return congruent_tfrecords
    

# %%

def get_congruent_data(df, label_col='label', sample_size: int=None):
    """ Prepares congruent tfrecord combinations (same action class).
        If sample_size is not given, this function pairs each video with 
        every other video in the same class. If sample_size is given, 
        it samples that number of congruent videos per video, and also 
        uses the original intact videos.
    """
    
    sampler = all_possible_filename_combinations
    if sample_size:
        sampler = sample_filename_combinations
    
    congruent = []
    for label in df[label_col].unique(): # for each label
        
        # get tfrecords only for this label
        label_mask = df[label_col] == label
        label_tfrecords = df.loc[label_mask, 'tfrecord_filename']
        
        tfrecord_ls = list(label_tfrecords.values)
        
        congruent_tfrecords = sampler(tfrecord_ls)
        
        columns = ['audio_tfrecord', 'visual_tfrecord']
        congruent_this_label = pd.DataFrame(
            congruent_tfrecords,
            columns=columns
        )
        
        congruent.append(congruent_this_label)
        
    return pd.concat(congruent)

# %%

def get_incongruent_data(df, sample_size, label_col='label'):
    """ Prepares semantically incongruent tfrecord pairs. A sample size should 
        be chosen such that each video is paired with an equal number of videos 
        from each incongruent class. sample_size refers to the number of 
        samples taken from each label for each video.
    """
    incongruent = []
    for label in df[label_col].unique(): # for each label
        
        # get data for this label
        label_mask = df[label_col] == label
        this_label_df = df.loc[label_mask]
        
        # get data for all OTHER labels
        not_label_mask = df[label_col] != label
        not_label_df = df.loc[not_label_mask]
        
        for index, vid_row in this_label_df.iterrows(): # each vid of label
            
            f = vid_row['tfrecord_filename']
        
            # sample incongruent data for single video
            incongruent_samples = not_label_df.groupby(label_col).sample(
                sample_size,
                random_state=0
            )
            incongruent_tfrecords = incongruent_samples['tfrecord_filename']
            
            # audio and visual tfrecord pairs (incongruent)
            incong_tuples = [(f, incong) for incong in incongruent_tfrecords]
    
            columns = ['audio_tfrecord', 'visual_tfrecord']
            incongruent_this_label = pd.DataFrame(
                incong_tuples,
                columns=columns
            )
            
            incongruent.append(incongruent_this_label)
        
    return pd.concat(incongruent)    


# %% Remove silent videos by merging the MIT-16 dataframe with the previously 
#    prepared `audio_or_not.csv', and then filter out those videos without 
#    an audio stream.

audio_or_not = audio_or_not[['tfrecord_filename', 'audio?']]

MIT16_train_df = MIT16_train_df.merge(
    audio_or_not,
    on='tfrecord_filename',
    how='left'
)

MIT16_val_df = MIT16_val_df.merge(
    audio_or_not,
    on='tfrecord_filename',
    how='left'
)

# rm silent videos
MIT16_train_df = MIT16_train_df[MIT16_train_df['audio?']]
MIT16_val_df = MIT16_val_df[MIT16_val_df['audio?']]

# %% Number of samples to take from each label, such that congruent and 
#    incongruent pairings balance across labels. The number of samples chosen 
#    should be divisible by the number of incongruent classes (15)

num_AVMIT_train_samples = 405 # must be divisible by 15 (num_incong_classes)
num_AVMIT_val_samples = 45

# now there are 604 pouring vids in MIT16 train, take 600 (600 % 15 = 0)
num_MIT16_train_samples = 600
# now 71 pouring vids in MIT16 val, take 60 (60 % 15 = 0)
num_MIT16_val_samples = 60


AVMIT_train_df = AVMIT_train_df.groupby('label').sample(
    num_AVMIT_train_samples,
    random_state=0
)
AVMIT_val_df = AVMIT_val_df.groupby('label').sample(
    num_AVMIT_val_samples,
    random_state=0
)

MIT16_train_df = MIT16_train_df.groupby('AVMIT label').sample(
    num_MIT16_train_samples,
    random_state=0
)
MIT16_val_df = MIT16_val_df.groupby('AVMIT label').sample(
    num_MIT16_val_samples,
    random_state=0
)

# %% Get congruent and incongruent tfrecord pairings for AVMIT

# train
AVMIT_train_cong = get_congruent_data(AVMIT_train_df, label_col='label')
AVMIT_train_incong = get_incongruent_data(
    AVMIT_train_df,
    sample_size=int(num_AVMIT_train_samples/15),
    label_col='label'
)

# val
AVMIT_val_cong = get_congruent_data(AVMIT_val_df, label_col='label')
AVMIT_val_incong = get_incongruent_data(
    AVMIT_val_df,
    sample_size=int(num_AVMIT_val_samples/15),
    label_col='label'
)

# %% Get congruent and incongruent tfrecord pairings for MIT-16

# train
MIT16_train_cong = get_congruent_data(
    MIT16_train_df,
    label_col='AVMIT label'
)
MIT16_train_incong = get_incongruent_data(
    MIT16_train_df,
    sample_size=(num_MIT16_train_samples/15), # sample 600/15 from each class
    label_col='AVMIT label'
)

# val
MIT16_val_cong = get_congruent_data(
    MIT16_val_df,
    label_col='AVMIT label'
)
MIT16_val_incong = get_incongruent_data(
    MIT16_val_df,
    sample_size=(num_MIT16_val_samples/15), # sample 60/15 from each class
    label_col='AVMIT label'
)

# %% Write to csv

AVMIT_train_cong.to_csv(
    'AVMIT_train_cong.csv',
    index=False
)
AVMIT_train_incong.to_csv(
    'AVMIT_train_incong.csv',
    index=False
)

AVMIT_val_cong.to_csv(
    'AVMIT_val_cong.csv',
    index=False
)
AVMIT_val_incong.to_csv(
    'AVMIT_val_incong.csv',
    index=False
)

MIT16_train_cong.to_csv(
    'MIT16_train_cong.csv',
    index=False
)
MIT16_train_incong.to_csv(
    'MIT16_train_incong.csv',
    index=False
)

MIT16_val_cong.to_csv(
    'MIT16_val_cong.csv',
    index=False
)
MIT16_val_incong.to_csv(
    'MIT16_val_incong.csv',
    index=False
)